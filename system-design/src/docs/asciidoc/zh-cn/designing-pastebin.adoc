== 设计Pastebin

让我们设计一个类似Pastebin的Web服务，用户可以在其中存储普通的文本。该服务的用户将会输入一段文本并获得一个随机生成的URL来访问它。类似的服务有：pastebin.com, pasted.co, chopapp.com。难度级别：简单。

=== 1. 什么是Pastebin?

类似Pastebin的服务可以使用户通过网络（通常是Internet）存储普通文本或者图片，并生成唯一的URL来访问上传的数据。此类服务还可以通过互联网快速分享数据，因为用户只需要传递URL即可让其他用户看到数据。

如果你之前没有使用过pastebin.com，请尝试在此网站上创建一个新的‘Paste’，并花费一点儿时间浏览该服务提供的各种选项。这将有助于你理解本章内容。

=== 2. 系统需求和目标

我们的Pastebin服务应该满足以下需求：

功能性需求：::

. 用户应该可以上传或者“粘贴”他们的数据，并获取一个唯一的URL来访问它。
. 用户只能上传文本数据。
. 数据和链接将会在特定时间段之后自动过期；用户应该也可以指定过期时间。
. 用户应该也可以选择为其粘贴的数据指定别名。

非功能性需求：::

. 系统应该高可靠，上传的数据应不会丢失。
. 系统应该高可用。这是必需的，因为如果我们的服务宕机，那么用户将不能访问他们的Pastes。
. 用户应该可以在最小延迟时间内即时访问他们的数据。
. Paste的链接不应该用户被猜测到（不可预测的）。

扩展需求：::

. 分析。比如：一个链接被访问了多少次？
. 其他服务应该可以通过REST APIs访问我们的服务。

=== 3. 设计注意事项

Pastebin和URL压缩服务的一些需求相同，但是还有一些我们应该牢记的其他设计事项。

用户一次粘贴的文本数量的限制应该是多少？我们可以限制用户粘贴的数据大小不超过10MB，以防止用户滥用服务资源。

我们应该对自定义网址设置大小限制吗？由于我们的服务支持自定义URL，因此用户可以选择他们喜欢的任何URL，但是并非必须提供自定义URL。然而，对自定义URL限制大小是合理的（并且通常是可取的），以便我们拥有一致的URL数据库。

'''

=== 4. 容量估算和约束

我们的服务将会有大量的读请求；相比于新的Paste的创建，会有更多的读请求。假如读请求和写请求的比例是5：1.

*流量估算*：Pastebin服务不期望流量和Twitter或者Facebook一样多，假设每天有一百万个新的paste新增到我们的系统中。这使我们每天有5百万次读请求。

每秒创建新的Paste：

[source,text]
----
    1,000,000 / (24小时 * 3600秒) ~= 12 pastes/sec
----

每秒读paste：

[source,text]
----
    5,000,000 / (24 hours * 3600 seconds) ~= 58 reads/sec
----

*存储估算：* 用户最多可以上传10MB的数据；通常，类似Pastebin的服务用户共享源代码、配置或者日志。这样的文字不是很大，假设每次粘贴平均包含10KB的数据。

按照这个速率，每天将存储10GB的数据。

[source,text]
----
    1M * 10KB => 10 GB/day
----

如果我们想将这些数据存储10年，那么我们将需要36TB的总存储容量。

每天1百万次的数据粘贴，那么10年将会有36亿次的数据粘贴。我们需要为这些数据生成并存储唯一识别的键。如果使用Base64编码（[A-Z, a-z, 0-9, ., -]）,将需要6个字母的字符串：

[source,text]
----
    64^6 ~= 68.7 billion unique strings
----

如果一个字节存储一个字符，存储36个键的总空间大小为：

[source,text]
----
    3.6B * 6 => 22 GB
----

22GB与36TB相比可以忽略不急。为了留有余地，我们将采用70%模型（意味着在任何时候我们都不希望使用总存储容量的70%以上的空间），这将会把存储空间的大小提升到51.4TB。

*带宽预估：* 对于一个写请求来说，我们期望每秒有12个新的粘贴数据，从而导致每秒有120KB大小的数据增长。

[source,text]
----
    12 * 10KB => 120 KB/s
----

对于读请求，我们期望每秒有个58个请求。因此，传出的总数据（发送给用户）是0.6MB/s。

[source,text]
----
    58 * 10KB => 0.6 MB/s
----

虽然每秒总出入的数据不大，但是我们设计服务时应该牢记这些数据。

*内存预估：* 我们可以缓存一些频繁访问的热点paste数据。根据80-20原则，意味着20%的热点paste数据将产生80%的流量，我们想要缓存这20%的paste数据。

因为每天有5百万个读请求，因为缓存这些请求的20%，需要的空间大小是：

[source,text]
----
    0.2 * 5M * 10KB ~= 10 GB
----

'''

=== 5. 系统APIs

我们可以使用SOAP或者REST APIs来暴露我们服务的功能。以下定义的APIs是用来创建、检索和删除paste的API：

[source,text]
----
    addPaste(api_dev_key, paste_data, custom_url=None user_name=None, paste_name=None, expire_date=None)
----

* *参数：*
+
api_dev_key (string): :: 注册账户的开发者密钥。除此之外，这将用于根据用户分配的配额来节流。
paste_data (string): :: 粘贴的文字数据；
custom_url (string): :: 可选的自定义URL；
user_name (string): :: 用于生成URL的可选的用户名；
paste_name (string): :: 可选的paste的名称；
expire_date (string): :: 可选的为paste指定过期时间。

* *返回值：* (string)
+
paste成功新增后返回一个可以访问此paste的URL，否则，返回一个错误码。

类似地，还有检索和删除的API：

[source,text]
----
    getPaste(api_dev_key, api_paste_key)
----

“api_paste_key”是一个表示要检索paste的密钥。这个API将会返回paste的文本数据。

[source,text]
----
    deletePaste(api_dev_key, api_paste_key)
----

成功删除返回‘true’，否则返回‘false’。

=== 6. 数据库设计

关于要存储的数据的特性: ::

. 需要存储数十亿条记录；
. 存储的每一个元数据对象都很小（不超过100字节）；
. 每一个将要存储的paste对象都是中等大小的（它可以是几MB）；
. 记录之间没有关系，除非我们想保存哪个用户创建了哪些Paste；
. 我们的服务会有大量的读请求。

*数据库表：*

我们需要两张表，一个存储Paste相关的信息，一个存储用户数据。

.Paste
[width="25%",cols=">s,>m,e"]
|===
3+| Paste
| PK|URLHash: varchar(16)|
| |ContentKey: varchar(512)|
| |ExpirationDate: datetime|
| |CreationDate: datetime|
|===

.User
[width="25%",cols=">s,^m,e"]
|===
3+| User
|PK|UserID: int|
||Name: varchar(20)|
||Email: varchar(32)|
||CreationDate: datetime|
||LastLogin: datetime|
|===

在这里，‘URLHash’等同于TinyURL中的URL，‘ContentKey’是存储paste内容的对象键值。

=== 7. 高级设计

在高层次上，我们需要一个应用层来处理所有的读写请求。应用层将与数据层通信进行数据存储和检索。可以将存储层进行分隔，一个数据库存储paste、用户等相关的元数据，而paste的内容存储在一些对象存储中（例如Amazon S3）。这种数据划分将允许我们独立地扩展他们。

image::https://jcohy-resources.oss-cn-beijing.aliyuncs.com/jcohy-docs/images/system-design-interview/pastebin/metadata-storage.png[caption="",title="元数据存储"]

=== 8. 组件设计

.. *应用程序层*
+
应用程序层将会处理所有的请求和响应。应用程序服务器将会与后端数据存储组件通信以服务请求。
+
*如何处理写请求？* 接收到写请求后，应用程序服务器将会生成一个6位字母的随机字符串，它将会作为paste的键（如果用户没有提供自定义键）。然后应用服务器将paste的内容和生成的键存储到数据库中。插入成功后，服务器会把生成的键返回给用户。这里可能会有的一个问题是，因为重复的键导致数据插入失败。因为生成随机键时，有一定的几率会生成一个已经存在的键。在这种情况下，我们将会重新生成键，并重新尝试数据入库。我们应该一直重试，直到因为重复键导致的失败消失。如果用户提供的自定义键已存在于数据库中，应该向用户返回一个错误。
+
解决上述问题的另一个方案是，运行一个独立的密钥生成服务（KGS），它预先生成随机的六个字母的字符串并存储到数据库中（称之为key-DB）。当我们想要存储新的paste时，将只需获取一个已生成的密钥并使用它。这种方法将会使事情变得简单快捷，因为我们无需担心键重复或者冲突的问题。KGS将会保证所有新增到Key-DB中的密钥是唯一的。KGS会使用两张表存储密钥，一张表存储未使用的密钥，另一张表存储已使用的密钥。一旦KGS将一些密钥提供给应用服务器，它将会把这些密钥移动到已使用的密钥表中。KGS总会缓存一些密钥在内存中，以便当服务器需要密钥时，可以很快的提供给它。一旦KGS将一些密钥加载到内存中，这些密钥将会被移动到已使用的密钥表中，这种方式确保每个服务器获取的密钥都是唯一的。如果KGS在这些加载到内存的密钥未使用完之前宕机，那么就会浪费掉这些密钥。鉴于我们有大量的密钥，我们可以忽略掉这些丢失的。
+
*KGS不会单点故障吗？* 是的，它会。为了解决这个问题，我们可以拥有一个KGS的备份，当主服务宕机时，它就会成为主服务，来生成并提供密钥。
+
*每个应用服务器都可以缓存一些key-DB的密钥吗？* 是的，这会使服务变得更快。尽管在这种情况下，如果在应用服务在未消耗完这些密钥之前就宕机，会导致我们最终丢失这些密钥。但这是可接受的，因为我们有68亿个唯一的6个字母的密钥，这远超过我们所需要的数量。
+
*如何处理一个paste的读请求？* 在收到读取paste的请求后，应用层会与数据存储层进行通信。数据存储层会检索这个密钥，如果它存在，则返回paste的内容；否则，返回一个错误码。

.. *数据存储层*
+
可以将数据存储层划分为两个：
+
. 元数据库：可以使用关系型数据库，如MySQL，或者分布式键值存储，如Dynamo或者Cassandra。
. 对象存储：可以将内容存储在如Amazon的S3这样的对象存储中。每当我们想要充分利用内容存储容量时，可以通过增加更多的服务轻松增加容量。
+
image::https://jcohy-resources.oss-cn-beijing.aliyuncs.com/jcohy-docs/images/system-design-interview/pastebin/detailed-component-design-for-pastebin.png[caption="",title="Detailed component design for Pastebin"]

=== 9. 清除或数据库清理

请参考link:designing-a-url-shortening-service-like-tinyurl.adoc#10-清除或数据库清理[设计URL压缩服务] 。

=== 10.	数据分区和备份

请参考link:designing-a-url-shortening-service-like-tinyurl.adoc#7-数据分区和备份[设计URL压缩服务]。

=== 11.	缓存和负载均衡

请参考link:designing-a-url-shortening-service-like-tinyurl.adoc#8-缓存[设计URL压缩服务]。

=== 12.	安全和权限

请参考link:designing-a-url-shortening-service-like-tinyurl.adoc#12-安全和权限[设计URL压缩服务]。
